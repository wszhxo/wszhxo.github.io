# 策略模式



定义不同的规则,最终可随意替换组合成需要的模式

举例:    比如八大排序算法相当于八个规则,加上升序还是降序的规则组成最终算法

```
package com.company;

public class 策略模式 {
    public static void main(String[] args) {
        排序算法 p=new 最终组成算法1(new 快速排序(), new 升序());
        p.display();
        p.setA(new 降序());
        p.display();
    }
}
//规则
interface 算法{
    void arithmetic();
}
//规则
interface 升降序{
    void sort();
}

//排序规则具体实现
class 升序 implements 升降序{
    @Override
    public void sort() {
        System.out.print("升序");
    }
}
//排序规则具体实现
class 降序 implements 升降序{
    @Override
    public void sort() {
        System.out.print("降序");
    }
}
//排序算法具体实现
class 快速排序 implements 算法{
    @Override
    public void arithmetic() {
        System.out.print("快速排序");
    }
}


abstract class 排序算法{

    abstract public void display();
    算法 p;
    升降序 a;
    abstract void arithmetic();
    abstract void sort();

    public 排序算法(算法 p, 升降序 a) {
        this.p = p;
        this.a = a;
    }

    public void setP(算法 p) {
        this.p = p;
    }

    public void setA(升降序 a) {
        this.a = a;
    }

    public 算法 getP() {
        return p;
    }

    public 升降序 getA() {
        return a;
    }
}

//可构建多个不同的算法组合
class 最终组成算法1 extends 排序算法{

    public 最终组成算法1(算法 p, 升降序 a) {
        super(p, a);
    }

    @Override
    public void display() {
        System.out.print("得到最终的算法1是:");
        p.arithmetic();
        a.sort();
    }

    @Override 
    void arithmetic() {
        p.arithmetic();
    }

    @Override
    void sort() {
        a.sort();
    }
}
```

应用

Arrays工具类