---
title: 哈希表(数组+链表实现)
categories:
  - java基础
tags:
  - 数据结构
  - 哈希表
abbrlink: 2879524665
---


## 什么是哈希表

[散列表](https://baike.baidu.com/item/散列表/10027933)（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的[数据结构](https://baike.baidu.com/item/数据结构/1450)。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。
<!--more-->

## 哈希表的应用

根据哈希表查询速度快的特点可以应用在缓存中,比如redis.众所周知,一个项目的短板一般都在数据库的读写中,就像电脑短板就在硬盘读写速度,有了固态硬盘后,电脑的整体速度就有了质的飞跃.

## 数据结构

数组+链表的形式,链表中的每个结点都包含Person类和下一个结点

![1568896984902](哈希表(数组+链表实现)/1568896984902.png)

## 定义链表结点

id就相当于键,name相当于值,next仅仅是用于记录下一个结点

```java
//定义人实体类结点
class Person{
	public  int  id;
	public String name;
	public Person next;
	public Person(int id, String name) {
		this.id = id;
		this.name = name;
	}
	@Override
	public String toString() {
		return "Person [id=" + id + ", name=" + name + "]";
	}
	
}
```

## 定义链表类

包含添加,查看,查询方法

```java
class LinkedList{
	public Person head;
	public void add(Person person) {
		//为空就直接赋值头结点
		if (head==null) {
			head=person;
			return;
		}
		//临时变量因为不能让head发生改变
		Person temp=head;
		//在尾部加入新结点
		while(true) {
			if(temp.next==null) {
				break;
			}
			temp=temp.next;
		}
		temp.next=person;
	}
	public void list() {
		if (head==null) {
			System.out.println("空");
			return;
		}
		//临时变量因为不能让head发生改变
		Person temp=head;
		while(true) {
			System.out.print(temp.toString()+" ");
			if(temp.next==null) {
				break;
			}
			temp=temp.next;
		}
		System.out.println();
	}
	public Person findById(int id) {
		Person temp=head;
		if (temp==null) {
			System.out.printf("没有id=%d的元素",id);
			return null;
		}
		
		while(true) {
			//线性查找,找到返回
			if (id==temp.id) {
				break;
			}
			//遍历完了都没有,那就是找不到了,因为要返回temp所以让temp=null;
			if (temp.next==null) {
				temp=null;
				break;
			}
			temp=temp.next;
		}
		return temp;
	}
}
```

## 定义数组

数组中的每个元素都是一个链表,链表的添加,查看,查询方法都要由数组体现

每个链表person类中的id都是数组大小取模后对应的下标

```java
//数组
class HashTable{
	public LinkedList[] arr;
	public int size;
	public HashTable(int size) {
		this.size=size;
		arr=new LinkedList[size];
		//对象数组是需要实例化的,不像int数组会自动赋值0
		for (int i = 0; i < arr.length; i++) {
			arr[i]=new LinkedList();
		}
	}
	
	public void list() {
		for (int i = 0; i < size; i++) {
			arr[i].list();
		}
	}

	public Person findById(int id) {
		return arr[this.hash(id)].findById(id);
	}
	public void add(Person person) {
		//把person.id hash之后的下标中加入
		arr[this.hash(person.id)].add(person);
	}
	//比如size=7,那么0-6加完后,7%7还是从0开始加入
	public int hash(int id) {
		return id % size;
		
	}
	
	  
}
```

## 测试类

```java
	public static void main(String[] args) {
		HashTable arr=new HashTable(6);
		arr.add(new Person(3, "张三"));
		arr.add(new Person(1, "找一"));
		arr.add(new Person(7, "张气"));
		arr.add(new Person(10, "赵氏"));
		arr.list();
		System.out.println("=================");
		Person findById = arr.findById(3);
		System.out.println(findById.toString());
	}
```

## 输出

```java
空
Person [id=1, name=找一] Person [id=7, name=张气] 
空
Person [id=3, name=张三] 
Person [id=10, name=赵氏] 
空
=================
Person [id=3, name=张三]

```





