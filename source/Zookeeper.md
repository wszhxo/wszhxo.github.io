---
title: Zookeeper
date: 2020-08-18 22:29:13
tags:
  - 分布式
  - Zookeeper
categories: 框架
---

# Zookeeper

Zookper是一个文件系统类型的数据库，创建结点必须要有/斜杠





`zkServer.sh start 后边加上cfg的文件路径`

就能启动服务,配置多个cfg就可以启动多个服务 ,

`zhCli.sh -server ip:端口`

启动客户端,可以改变端口和ip连接不同的客户端

当在A客户端创建结点后,B客户端也能访问到A的结点,具有**数据一致性的分布式**



### 强一致性

某一个用户更新数据库A的数据比如value=2,另外一名用户在集群中从数据库B读取到的value一定要是2,这样就要求数据库之间的同步非常迅速,或者加上锁同步完成后才能读到同步后的数据

### 弱一致性

允许用户读取到同步之前的旧数据

### 最终一致性

允许读到旧数据,但一段时间后一定要是新数据

## CAP

Consistency:强一致性

Avalibility:可用性,集群可不可用

Partition Tolerance:分区容错性 

**分区容错性**:分布式架构中,由于很多模块都分开部署,比如在不同的服务器,这就是分区了 ,但此时模块之间的交互就需要网络很快,网络越快容错性就越高,这就是分区容错性



一个集群需要对外部提供强一致性,所以只要集群内部某一台服务器发生了改编,那么就需要等待集群内其他服务器的数据同步完成后才能正常对外提供服务

保证了强一致性,通常需要存好可用性

## 如何保证一致性

上课时老师讲完一个知识点通常会问,懂了没有,当有**大部分学生**懂了,老师就会认为同学懂了,老师不会确保所有学生都听懂了,(**过半机制**)

其中老师和同学就是不同的服务器,老师是老大,老师讲课过程就是同步的过程,同学们回答懂了,就是完成了同步,同步数据的任务就交给老大服务器

**谁的数据越新谁就是老大**,判断依据就是一个**事务id叫做zxid**,是一个自增id,每次进行**事务性请求(增删改)**时就会自增,非事务性请求(查询)就不会改变id,

## 选举机制

如何选择老大,需要投票,首先每个**服务启动时**会进行类似于淘汰赛的**选举机制**,

选出zxid最大的作为老大服务器,如果zxid相同则选择myid最大的,谁最后启动最大,新建请求就由老大处理,并同步到子服务器,

当新进来一个服务器时,不管zxid比老大的zxid大还是小,为了保证稳定性,都要与老大服务器同步,

老大服务器(leader)挂掉之后,就会重新进行选举机制,当子服务器挂掉,导致少于一半的跟随服务器(follower),也会重新进行选举机制

## 同步过程

首先leader服务器**预提交**,就是在follower服务器中创建事务日志,事务日志中包含了具体的修改数据过程,当follower服务器保存成功则返回ack给leader服务器,

当有大于一半的服务器都返回了ack,则开始真正的同步数据(**提交**),就是把事务日志中的操作变成各个follower服务器的datatree中具体的数据

当有7台服务器,`7/2=3`因此只要大于3就算是过半,



三台服务器在A机房,三台服务器在B机房,就会存在两个老大的问题,会导致数据不一致,