## 缓存三种模式

一般来说，缓存有以下三种模式：

- Cache Aside 更新模式
- Read/Write Through 更新模式
- Write Behind Caching 更新模式

### Cache Aside 更新模式

这是最常用的缓存模式了，具体的流程是：

- **失效**：应用程序先从 cache 取数据，没有得到，则从数据库中取数据，成功后，放到缓存中。
- **命中**：应用程序从 cache 中取数据，取到后返回。
- **更新**：先把数据存到数据库中，成功后，再让缓存**失效**。

**坑1.为什么不直接更新缓存？**

Springboot有自带的默认缓存方式，和Cache Aside类似，但是更新时不一样， @CachePut 这个注解就是先更新数据库，后更新缓存，当两个**并发写操作**AB同时更新时，也许会产生执行时间不一致，比如A比B先执行，A更新了数据库后更新缓存花费100ms，B只在50ms内执行完，但是B其实才是最新的数据，但此时缓存中还是A的旧数据，于是就有了脏数据

![1594348126859](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1594348126859.png)

 **坑2.先删除缓存，再更新数据库** 

两个并发操作，**写操作A**在删除缓存后更新了数据库前，**读操作B**就拿到了老数据并且缓存中也变成老数据，所以产生了脏数据，以后读取的都是老数据，解决方法是**设置缓存过期时间**，减小影响

**比较好的做法先更新数据库，再删除缓存**

Cache Aside也存在概率极低的数据一致性问题

读操作A把数据库的老数据更新到缓存的过程中，B更新了数据库删除了缓存，A执行慢，因此数据库是新数据，缓存中是老数据，但是因为缓存已经被B删除，下次得到的还是新数据，因此影响很小





## 总结

三种缓存模式的优缺点：

- Cache Aside 更新模式实现起来比较简单，但是需要维护两个数据存储，一个是缓存（Cache），一个是数据库（Repository）。
- Read/Write Through 更新模式只需要维护一个数据存储（缓存），但是实现起来要复杂一些。
- Write Behind Caching 更新模式和Read/Write Through 更新模式类似，区别是Write Behind Caching 更新模式的数据持久化操作是异步的，但是Read/Write Through 更新模式的数据持久化操作是同步的。优点是直接操作内存速度快，多次操作可以合并持久化到数据库。缺点是数据可能会丢失，例如系统断电等。



參考https://juejin.im/post/5af5b2c36fb9a07ac65318bd