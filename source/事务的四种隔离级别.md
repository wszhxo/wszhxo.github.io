---
title: 事务的四种隔离级别
categories:
  - java基础
tags:
  - mysql
  - 事务
abbrlink: 15451436
---


>  事务在并发情况下会出现以下情况`脏读`,`不可重复读`,`幻读`,事务的四种隔离级别分别为了逐级解决这三个问题

<!--more-->

**脏读**:表table, A开启事务先给table修改了一条数据,提交事务之前,B读到了修改后的内容,之后A并没有提交事务,而回滚,出现了前后数据的不一致,这就是脏读(**侧重修改进行中读到数据的不同**),

**不可重复读**:表table, B读到一条内容,此时A开启事务**修改**了一条数据并提交事务,B再次读数据,数据前后不一致(**侧重修改前和修改后读到数据的不同**)

**幻读**:表table, B读到一条内容,此时A开启事务**添加**了一条数据并提交事务,B再次读数据,数据前后不一致(**侧重添加前和添加后读到数据的不同**)

## 读未提交(Read uncommitted)

这个级别什么问题都没解决,所以不采用这个级别

## 读已提交(Read committed)

解决了`脏读`

## 重复读(Repeatable read)

解决了`脏读`和`不可重复读`

## 序列化(Serializable)

解决了`脏读`,`不可重复读`和`幻读`

## 数据库ACID四大特性

这个千万不要和上述的4种隔离界**别搞混**

### 1. 原子性

> 原子性是指事务是一个**不可再分割的工作单元**，事务中的操作要么都发生，要么都不发生。
>
> 可采用“**A向B转账**”这个例子来说明解释

### 2. 一致性

> 类似于非黑即白,不存在黑白分界有灰的状态,意思就是读到的数据要么是黑要么是白,执行提交事务代码的过程可以理解为灰就是临界过程,这个过程可以理解为不存在

### 3. 隔离性

> **多个事务并发访问时，事务之间是隔离的**，一个事务不应该影响其它事务运行效果。
>
> 在并发环境中，当**不同的事务同时操纵相同的数据**时，每个事务都有**各自的完整数据空间**。由并发事务所做的修改必须与任何其他并发事务所做的修改隔离。事务查看数据更新时，数据所处的状态要么是另一事务修改它之前的状态，要么是另一事务修改它之后的状态，**事务不会查看到中间状态的数据**。

### 4. 持久性

> 这是最好理解的一个特性：持久性，意味着在事务完成以后，**该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。**（完成的事务是**系统永久的部分**，对系统的影响是永久性的，该修改即使出现致命的系统故障也将一直保持）

