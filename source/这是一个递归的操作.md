这是一个递归的操作

![image-20210109141421253](C:\Users\25006\AppData\Roaming\Typora\typora-user-images\image-20210109141421253.png)

因为只有Bean初始化initalizeBean(A)成功,单例池中才会有对象,因此对象B在getBean(A),时发现A没有,因此又会开始实例化,创建属性,初始化,一直死循环

## spring解决死循环:半成品池(二级缓存)

因此spring引入了一个 半成品池,他会在实例化完成后就会把对象放入,所以B在getBean(A)时发现单例池中没有,就会去半成品池中找,发现有,就解决了死循环问题,单例池先把B装入,再把A装入,完成后半成品池的A就拿掉了

## spring解决AOP和死循环问题:工厂池(三级缓存)

AOP是在**初始化**对象完成后执行的(后置处理),虽然单例池中的对象是代理对象,但是半成品池中的对象还是之前的对象,因此使用AOP时这个半成品池就会有问题, 为了解决这个问题,就引入了工厂池,比如在**实例化阶段**B创建A对象的过程中,提前在工厂池中生成代理对象A也就是factory(A)把他放入半成品池(提前引用),当然在A实例化createBeanInstance(B)的时候也会生成factory(B),但是在初始化完成后都会删除,以此来解决B拿到的是代理对象A

