---
title: 单例设计模式
categories:
  - java基础
abbrlink: 3442686983
---

单例设计模式简单来讲就是只有一个实例的设计方法

它分为懒汉式和饿汉式;那么为什么要有这种模式呢?

<!--more-->

一台电脑只有一个回收站吧,打开回收站,再次打开回收站其实都是同一个

一个班级只有一个班主任,我找班主任有点事,你也找他,我们要找的都是同一个;

## 设计要点

- 类只能有一个实例

- 构造方法私有化

- 向外提供这一个实例

## 单例之懒汉模式

懒汉意思就是不需要的时候,啥都不干,我叫你干活才干活

```java
public static lazySingle lsLazySingle;
	private lazySingle() {}
	public static lazySingle getInstance() {
		if (lsLazySingle==null) {
            //(1)多线程出现问题的位置
				lsLazySingle=new lazySingle();
		}
		return lsLazySingle;
	}
```

### 优点:

减少内存开销,设计简单

### 缺点:

线程不安全,为什么呢,因为如果有A 和 B 线程同时进来,A到(1)的位置,这时B抢占了A的cpu时间,那么也进来了,执行之后A和B就创建了两个不同实例那么就违反了单例

## 单例之饿汉模式

饿汉意思就是,我都不需要你干活,你还是时刻准备;

```java
public static final hungrySingle hsHungrySingle=new hungrySingle();
	private hungrySingle() {}
	public static hungrySingle getInstance() {
		return hsHungrySingle;
	}
```

### 优点:

在编译期间就实例化了,需要就拿,线程安全,设计简单

### 缺点:

浪费内存,因为,我不需要,你还是实例化了,那不是浪费嘛

改进版饿汉模式使用内部类,需要时才创建 

```java
private static class InnerClass{
    public static final hungrySingle hsHungrySingle=new hungrySingle();

}
private hungrySingle() {}
public static hungrySingle getInstance() {
    return InnerClass.hsHungrySingle;
}
```



## 改进懒汉式

添加同步代码块

```java
class LsLazySingle{
    public static lazySingle lsLazySingle;
    private lazySingle() {}
    public static lazySingle getInstance() {
        if (lsLazySingle==null) {
            //(1)多线程出现问题的位置
            synchronized (LsLazySingle) {
                lsLazySingle=new lazySingle();
            }
        }
        return lsLazySingle;
     }
 }
```

但是这样似乎并没有解决多线程问题

因为就像上述所说的 A 和 B两个线程都进入(1),如果A拿到锁,B,在(1)等待,A进入后实例化对象,完成后释放锁,B进程还不是照样拿到之后可以进去嘛.

## 懒汉式双检锁

```java
class LsLazySingle{
    public static lazySingle lsLazySingle;
    private lazySingle() {}
    public static lazySingle getInstance() {
        if (lsLazySingle==null) {
            //(1)多线程出现问题的位置
            synchronized (LsLazySingle) {
                if (lsLazySingle==null) {
                	lsLazySingle=new lazySingle();
                 }
            }
        }
        return lsLazySingle;
     }
 }
```

在同步块里边再加上是否为空判断,

这样接着上边讲到的,A拿到锁,B在(1)处等待,实例化对象后,释放锁,这时候B进同步代码块,发现已经实例化,那么退出非空判断

**这就相对完善的单例模式了!**