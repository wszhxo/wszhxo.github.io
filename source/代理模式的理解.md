# 代理模式的理解

代理模式是结构型模式的一种,主要是为了降低系统耦合度

主要理解代理这个词语,其实就是中介的意思,代购不也是一个中介吗,比如我请代购人从海外代购一件商品,代购人一定是为了赚差价,而我需要商品,只不过价格变高了,代购人加了差价其实就是一种增强,这就是代理模式的核心了.

SpringAOP底层原理也是代理模式,比如日志记录,无非就是方法执行之前或者之后记录操作.

方法就相当于商品,日志记录就是增加的钱,SpringAOP就是代理人

```java
public interface GoodService {//这相当于需求
      	buyGoods();//买国外东西
}

public class GoodServiceImpl implements GoodService {
    public Good buyGoods() {
        Good f = new 奶粉();
        f.setNums("两个"); 
        return f;
    }
}


public class GoodServiceProxy implements GoodService {
    private GoodService goodService = new GoodServiceImpl();
     public Good buyGoods() {
        System.out.println("我帮你代购,原价1000元现在1500元");//增强代码

        Good good = goodService.buyGoods();//代购人开始买了

        System.out.println("奶粉帮你买好了"); // 增强增强代码

        return good;
    } 
}

//main方法
GoodService goodService = new GoodServiceProxy();
goodService.buyGoods();
```

`GoodServiceProxy`代理方法只不过是把原来的方法添加了一些增强代码,主要的功能其实没变。

## jdk动态代理

```java
public class 动态代理 {
	public static void main(String[] args) {
		Imessage3 imessage=(Imessage3) new MyProxy().bind(new ImessageImpl3());
		imessage.send();
	}	
}
interface Imessage3{
	public void send();
}
class ImessageImpl3 implements Imessage3{
	@Override
	public void send() {
		System.out.println("ImessageImpl3发送");
	}
}
class MyProxy implements InvocationHandler{
	private Object object;//传入原始对象
	public Object bind(Object object){//返回代理对象
		this.object=object;
		return Proxy.newProxyInstance(object.getClass().getClassLoader(), object.getClass().getInterfaces(), this);
}
	@Override
	public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
		System.out.println("增强方法开始");
		Object object=method.invoke(this.object, args);
		System.out.println("增强方法结束");
		return object;
	}
	
}
```

**为什么jdk动态代理必须基于接口** 
原因如下： 
1、生成的代理类继承了Proxy，由于java是单继承，所以只能实现接口，通过接口实现 

2、从代理模式的设计来说，充分利用了java的多态特性，也符合基于接口编码的规范 

为了迎合一些其他的开发人员要求也可以基于类,因此第三方**CGLIB动态代理**技术

,不过最常用的还是jdk动态代理