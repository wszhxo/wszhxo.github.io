---
title: 线索二叉树
categories:
  - java基础
tags:
  - 数据结构
  - 二叉树
abbrlink: 1245484299
---


对于二叉树的一个结点，查找其左右子树是方便的，其前驱后继只有在遍历中得到。**为了容易找到前驱和后继**，有两种方法。一是在结点结构中增加向前和向后的指针，这种方法增加了存储开销，不可取；

二是**利用二叉树的空链指针**。本文就是讲的这种
<!--more-->

线索二叉树能很快速地求出二叉树节点的前驱节点和后继节点，算法的复杂度为O(n)，虽然普通二叉树遍历求前驱和后继节点复杂度也是O(n)，**但线索二叉树的常数因子更小，求前驱和后继节点比普通二叉树遍历更快**。应用:堆排序等

## 中序线索二叉树

  先序线索二叉树查找后继节点容易、查找前驱节点困难；后序线索二叉树查找前驱节点容易、查找后继节点困难；而中序线索二叉树查找后继节点和先驱节点都很容易。因此，先序和后序线索二叉树应用较少，**中序线索二叉树应用更加广泛**。

![1569052699225](线索二叉树/1569052699225.png)

## 定义结点类



```java
class Human{
	public  int  id;
	public  String name;
	public Human left;//左孩子
	public Human right;//右孩子
	public int leftTag;//左标志0代表他有子结点,1表示前驱
	public int rightTag;//右标志0代表他有子结点,1表示后继
	public Human(int id,String name) {
		this.id = id;
		this.name = name;
	}
	@Override
	public String toString() {
		return "Human [id=" + id + "]";
	}
}
```

## 定义线索二叉树

定义根结点和前驱

```java
class ThreadedBinaryTree{
	Human root;
	Human pre=null;
	//线索化二叉树,中序线索
	public ThreadedBinaryTree(Human root) {
		this.root = root;
	}
	//中序线索化
	public void ThreadedMid(Human node) {
		//遍历到没有子节点时停止
		if (node==null) {
			return;
		}
		//左
		ThreadedMid(node.left);
		//当前结点线索化
		
		//没有左右结点(叶子结点)才需要前驱后继,
		if (node.left==null) {
			//第一次来是4,没有前驱就是pre为空
			node.left=pre;
			//表示有前驱
			node.leftTag=1;
		}
		//因为此时还不知道下一次遍历的元素,等到遍历到了才知道
		//第一次是执行不到的因为pre为空
		if (pre!=null&&pre.right==null) {
			//第二次来node=2,这是的pre就是4了
			//这一步才是把4的后继设置为2
			pre.right=node;
			pre.rightTag=1;
		}
		//让当前结点变成下一个结点的前驱
		pre=node;
		//右
		ThreadedMid(node.right);
	}
	//遍历方法
    //中序遍历
	public void list() {
		//从跟结点开始遍历
		Human node=root;
		
		while(node!=null) {
			//中序遍历从左开始,只要存在左子树那就一直到叶子结点停止
			while (node.leftTag==0) {
				node=node.left;
			}
			//到达叶子结点输出,第一次就是4
			System.out.println(node);
			//表示叶子结点有后继,那就输出,并指向下一个
			while(node.rightTag==1) {
				node=node.right;
				System.out.println(node);
			}
			//下一个,接着循环
			node=node.right;
		}
	}
}
```

## 测试

```java
public static void main(String[] args) {
		Human human1=new Human(1,"五一");
		Human human2=new Human(2,"王二");
		Human human3=new Human(3,"张三");
		Human human4=new Human(4,"李四");
		Human human5=new Human(5,"王五");
		Human human6=new Human(6,"赵六");
		human1.left=human2;
		human1.right=human3;
		human2.left=human4;
		human2.right=human5;
		human3.left=human6;
		//线索化
		ThreadedBinaryTree threadedBinaryTree=new ThreadedBinaryTree(human1);
		threadedBinaryTree.ThreadedMid(human1);
		//验证是否成功
		System.out.println(human4.right.toString());
    
        threadedBinaryTree.list();
	}

//输出Human [id=2, name=王二]说明正确

//中序遍历输出
Human [id=4, name=李四]
Human [id=2, name=王二]
Human [id=5, name=王五]
Human [id=1, name=五一]
Human [id=6, name=赵六]
Human [id=3, name=张三]
```

