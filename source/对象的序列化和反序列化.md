# 对象的序列化和反序列化

网络传输过程中都是用二进制的数据传输,因此需要序列化

序列化之后,打开本地文件`zhx.person`打开后,不是人能看懂的

```java
public class 序列化和反序列化 {
	public static File  STATIC_FILE=new File("D:"+File.separator+"zhx.person");
	public static void main(String[] args) throws FileNotFoundException, IOException, ClassNotFoundException {
		Person2 person2=new Person2(11,"zhx");
//		saveObject(person2);//序列化
		System.out.println(loadObject().toString());//反序列化

	}
    //序列化
public static void saveObject(Object object) throws FileNotFoundException, IOException{
	ObjectOutputStream outputStream=new ObjectOutputStream(new 		               FileOutputStream(STATIC_FILE));
	outputStream.writeObject(object);
	outputStream.close();
}
//反序列化
public static Object loadObject() throws FileNotFoundException, IOException, ClassNotFoundException{
	ObjectInputStream outputStream=new ObjectInputStream(new FileInputStream(STATIC_FILE));
	Object read = outputStream.readObject();
	outputStream.close();
	return read;
}
}
//需要序列化的实体类
class Person2 implements  Serializable{
	private static final long serialVersionUID = 1L;
	private int age;
	private String name;
	
	public Person2(int age, String name) {
		super();
		this.age = age;
		this.name = name;
	}
	public int getAge() {
		return age;
	}
	
	public void setAge(int age) {
		this.age = age;
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	@Override
	public String toString() {
		return "Person2 [age=" + age + ", name=" + name + "]";
	}
}

```

## transient

这个关键字修饰的属性表示不需要序列化,但是实际开发过程中很少用,因为序列化的都是简单java类