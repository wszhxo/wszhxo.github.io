# 装饰者模式

在不改变原有对象的情况下拓展功能,使用不同的组合可以实现不同的效果,符合开闭原则

>  开闭原则:一个软件实体应该通过扩展来实现变化,而不是通过修改已有的代码来实现变化

举例给一个手机加入新功能

```
public class 装饰者模式 {
    //Decorator
    public static void main(String[] args) {
        Phone phone=new phoneDecoratorImpl2(new phoneDecoratorImpl(new phoneImpl()));
        phone.call();
    }
}
interface Phone{
    void call();
}
class phoneImpl  implements Phone{
    @Override
    public void call() {
        System.out.println("手机打电话");
    }
}
//现在给手机加入一个新功能    定义一个抽象类手机装饰者
abstract  class phoneDecorator implements Phone{
    Phone phone;
    phoneDecorator(Phone phone){
        this.phone=phone;
    }
}
//装饰1:加入发短信功能
class phoneDecoratorImpl extends phoneDecorator{
    phoneDecoratorImpl(Phone phone) {
        super(phone);
    }
    @Override
    public void call() {
        System.out.println("发短信");
        phone.call();
    }
}
//装饰2:加入拍照功能
class phoneDecoratorImpl2 extends phoneDecorator{
    phoneDecoratorImpl2(Phone phone) {
        super(phone);
    }
    @Override
    public void call() {
        System.out.println("拍照");
        phone.call();
    }
}
```

应用

javax.servlet.http.HttpServletRequestWrapper

javax.servlet.http.HttpServletResponseWrapper