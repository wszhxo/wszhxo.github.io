---
title: 三柜台售100张票多线程问题
abbrlink: 2979
categories: 
- java基础
---





## 怎么在只有一张票时不出现线程安全问题?

<!--more-->





## 普通状态代码

``` java
public class Tickets implements Runnable{			
	private int ti=100;//100张票
	@Override
	public void run() {
		tickets();
	}	
}
public  void tickets() {
	while(true) {
		if (ti>0) {
					System.out.println(Thread.currentThread().getName()+"出售第"+ti--);
			}
		}
	
```

``` java
public static void main(String[] args) {
		Tickets t=new Tickets();
		//3个柜台同时卖票
		Thread t0=new Thread(t,"窗口一");
		Thread t1=new Thread(t,"窗口二");
		Thread t2=new Thread(t,"窗口三");
		t0.start();
		t1.start();
		t2.start();
	}
```



​	存在隐患也许会出现0,-1,-2的错误的极端线程安全问题,**但CPU运行速度很快出现几率很低,单不允许出现**!  

## 模拟不安全状态

``` java
	
	public void tickets() {
			if (ti>0) {
				try {
					Thread.sleep(10);
				} catch (InterruptedException e) {}
				System.out.println(Thread.currentThread().getName()+"出售第"+ti--);
			}
	}
```

``` 
窗口三出售第3
窗口二出售第2
窗口一出售第1
窗口二出售第0
窗口三出售第-1
```



**原因:在最后只有一张票的情况下,线程1进入ti>0判断,但没输出之前,线程2进来抢夺了资源,巧的是此时线程3又抢了线程2的资源,12就在之间休眠等着了,等线程3输出打印让出了资源,此时ti=0,线程12,原地苏醒,一打印,变成-2,**

这有一个输出乱序的小问题,本身控制台也是一个临界资源,需要同步访问,谁抢到谁先输出

## 添加同步方法

在让线程休眠10毫秒 模拟不安全情况 ,此时会**高几率**出现不安全情况 ,

加上同步后,类似于**上厕所把门关上**,把**同时共享的资源变成互斥共享也叫做临界资源**,由于开关门耗费了很多时间,因此线程安全**效率低**,不安全的效率高 

比如ArrayList,LinkList都是线程不安全所以运行速度很快

StringBuffer安全,StringBuilder不安全



``` java
	//同步方法
	public synchronized void tickets() {
			if (ti>0) {
				try {
					Thread.sleep(10);
				} catch (InterruptedException e) {}
				System.out.println(Thread.currentThread().getName()+"出售第"+ti--);
			}
	}
```

## 加锁



``` java
	
	private Lock lock= new ReentrantLock();
	//同步方法
	public void tickets() {
			lock.lock();//加锁
			if (ti>0) {
				try {
					Thread.sleep(10);
				} catch (InterruptedException e) {}
				System.out.println(Thread.currentThread().getName()+"出售第"+ti--);
			}
			lock.unlock();//释放锁
	}
```

效果相同!