# 公平锁/非公平锁/可重入锁/自旋锁/读写锁



## 公平锁/非公平锁

并发包中ReentrantLock的创建可以指定构造函数的boolean类型来得到公平锁或非公平锁，默认是非公平锁

### 关于两者区别:

公平锁:

就是很公平，在并发环境中，每个线程在获取锁时会先查看此锁维护的筹待队列，如果为空，或者当前线程是等待队列的第一个，就占有锁，否则就会加入到等待队列中，以后会按照FIFO的规则从队列中取到自己

非公平锁:

比较粗鲁，上来就直接尝试占有锁，如果尝试失败，就再采用类似公平锁那种方式。非公平锁的优点在于吞吐量比公平锁大。对于Synchronized而言，也是一种非公平锁

## 可重入锁(也叫做递归锁)
指的是同一线程外层函数获得锁之后﹐内层递归函数仍然能获取该锁的代码，在同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁也即是说，线程可以进入任何一个它已经拥有的锁所同步着的代码块。

**可以避免死锁**

线程获取到method1锁那么method2的锁自然也得到了

大体框架如下

```java
public sync method1(){
     method2();
}
public sync method2(){
    .....
}
```

具体demo

```java
class Phone implements Runnable{
    public synchronized void sendphone(){
        System.out.println(Thread.currentThread().getId()+"打电话");
        sendemail();
    }
    public synchronized void sendemail(){
        System.out.println(Thread.currentThread().getId()+"发短信");
    }

    @Override
    public void run() {
        get();
    }
    Lock reentrantLock=new ReentrantLock();
    private void get() {
        reentrantLock.lock();
        reentrantLock.lock();
        try {
            System.out.println(Thread.currentThread().getId()+"ReentrantLock打电话");
            set();
        }finally {
            reentrantLock.unlock();
        }
    }

    private void set() {
        reentrantLock.lock();
        try {
            System.out.println(Thread.currentThread().getId()+"ReentrantLock发短信");
        }finally {
            reentrantLock.unlock();
        }
    }
}
public class 可重入锁 {
    public static void main(String[] args) {
        Phone phone=new Phone();
        new Thread(()->{
            phone. sendphone();
        },"x1").start();
        new Thread(()->{
            phone. sendphone();
        },"x2").start();


        Thread thread1=new Thread(phone,"x3");
        Thread thread2=new Thread(phone,"x4");
        thread1.start();
        thread2.start();
    }
}
```



## 自旋锁

尝试获取锁的线程不会立即阻塞，而是采用循环的方式尝试获取锁，这样的好处是减少线程的上下文切换的小号，缺点是循环会消耗cpu,比如前边的线程很久都没有执行完,后边的线程一直循环等待

```java
public class 自旋锁 {
    AtomicReference<Thread> atomicReference=new AtomicReference<>();

    public  void mylock(){
        Thread thread=Thread.currentThread();
        System.out.println("======="+Thread.currentThread().getName()+"=加锁=");
        //获取当前线程,如果有人占着一直循环直到释放
        while(!atomicReference.compareAndSet(null,thread)){
        }
    }
    public  void myunlock(){
        Thread thread=Thread.currentThread();
        atomicReference.compareAndSet(thread,null);
        System.out.println("======="+Thread.currentThread().getName()+"=解锁=");
    }

    public static void main(String[] args) {

        自旋锁 z=new 自旋锁();
        new Thread(()->{
            z.mylock();
            try { Thread.sleep(5000); } catch (InterruptedException e) {  e.printStackTrace(); }
            z.myunlock();
        },"线程A").start();

        //休眠main线程为了让线程A能够先执行
        try {Thread.sleep(1000);} catch (InterruptedException e) {e.printStackTrace(); }

        //由于线程A一直持有锁,线程B一直在自旋循环,直到5秒钟结束A释放了锁,B接着释放锁
        new Thread(()->{
            z.mylock();
            z.myunlock();
        },"线程B").start();
    }
}
```



## 读写锁

读写分离,读的时候可以共享锁,但是写的时候一定要等待写入完成,

在没有加入读写锁的时候

```java
public class 读写锁 {
    private volatile Map map=new HashMap();
    private ReentrantReadWriteLock reentrantReadWriteLock=new ReentrantReadWriteLock();

    public void write(String key,String value) {
        System.out.println(Thread.currentThread().getName()+"writing.....");
        try { Thread.sleep(3000); } catch (InterruptedException e) {  e.printStackTrace(); }
        map.put(key,value);
        System.out.println(Thread.currentThread().getName()+"write done!");

    }
    public void read(String key) {
        System.out.println(Thread.currentThread().getName()+"reading.....");
        try { Thread.sleep(3000); } catch (InterruptedException e) {  e.printStackTrace(); }
        map.get(key);
        System.out.println(Thread.currentThread().getName()+"read done!");
    }

    public static void main(String[] args) {
        读写锁 z=new 读写锁();
        for (int i = 0; i < 3; i++) {
            int temp = i;
            new Thread(()->{
                z.write(temp +"", temp +"==");
            },"线程"+i).start();
        }
        for (int i = 0; i < 3; i++) {
            int temp = i;
            new Thread(()->{
                z.read(temp +"");
            },"线程"+i).start();
        }

    }
}

//输出结果出现多个线程同时写操作
线程0writing.....
线程2writing.....
线程1writing.....
线程0reading.....
线程1reading.....
线程2reading.....
线程2write done!
线程0write done!
线程1write done!
线程1read done!
线程0read done!
线程2read done!

```



加入读写锁后

```java
    private ReentrantReadWriteLock reentrantReadWriteLock=new ReentrantReadWriteLock();

    public void write(String key,String value) {
        reentrantReadWriteLock.writeLock().lock();
        System.out.println(Thread.currentThread().getName()+"writing.....");
        try { Thread.sleep(3000); } catch (InterruptedException e) {  e.printStackTrace(); }
        map.put(key,value);
        System.out.println(Thread.currentThread().getName()+"write done!");
        reentrantReadWriteLock.writeLock().unlock();

    }
    public void read(String key) {
        reentrantReadWriteLock.readLock().lock();
        System.out.println(Thread.currentThread().getName()+"reading.....");
        try { Thread.sleep(3000); } catch (InterruptedException e) {  e.printStackTrace(); }
        map.get(key);
        System.out.println(Thread.currentThread().getName()+"read done!");
        reentrantReadWriteLock.readLock().unlock();
    }


线程0writing.....
线程0write done!
线程1writing.....
线程1write done!
线程2writing.....
线程2write done!
线程0reading.....
线程1reading.....
线程2reading.....
线程0read done!
线程2read done!
线程1read done!

```

